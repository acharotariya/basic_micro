{
  "_args": [
    [
      {
        "raw": "micro@^6.0.2",
        "scope": null,
        "escapedName": "micro",
        "name": "micro",
        "rawSpec": "^6.0.2",
        "spec": ">=6.0.2 <7.0.0",
        "type": "range"
      },
      "/home/software1/microservices/auth"
    ]
  ],
  "_from": "micro@>=6.0.2 <7.0.0",
  "_id": "micro@6.2.1",
  "_inCache": true,
  "_location": "/micro",
  "_nodeVersion": "7.2.0",
  "_npmOperationalInternal": {
    "host": "packages-18-east.internal.npmjs.com",
    "tmp": "tmp/micro-6.2.1.tgz_1485452973738_0.3844911733176559"
  },
  "_npmUser": {
    "name": "leo",
    "email": "leo@zeit.co"
  },
  "_npmVersion": "3.10.9",
  "_phantomChildren": {},
  "_requested": {
    "raw": "micro@^6.0.2",
    "scope": null,
    "escapedName": "micro",
    "name": "micro",
    "rawSpec": "^6.0.2",
    "spec": ">=6.0.2 <7.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/micro/-/micro-6.2.1.tgz",
  "_shasum": "064d9e807cf8d132a820efc2ace7bad8d03a5c54",
  "_shrinkwrap": null,
  "_spec": "micro@^6.0.2",
  "_where": "/home/software1/microservices/auth",
  "author": {
    "name": "Zeit, Inc.",
    "email": "team@zeit.co"
  },
  "ava": {
    "require": [
      "async-to-gen/register"
    ],
    "files": [
      "test/index.js"
    ]
  },
  "bin": {
    "micro": "./bin/micro",
    "micro-serve": "./bin/micro"
  },
  "bugs": {
    "url": "https://github.com/zeit/micro/issues"
  },
  "dependencies": {
    "async-to-gen": "1.3.0",
    "is-async-supported": "1.2.0",
    "isstream": "0.1.2",
    "media-typer": "0.3.0",
    "minimist": "1.2.0",
    "raw-body": "2.2.0"
  },
  "description": "Asynchronous HTTP microservices",
  "devDependencies": {
    "ava": "^0.17.0",
    "request": "^2.74.0",
    "request-promise": "^4.1.1",
    "resumer": "0.0.0",
    "then-sleep": "^1.0.1",
    "xo": "^0.17.0"
  },
  "directories": {},
  "dist": {
    "shasum": "064d9e807cf8d132a820efc2ace7bad8d03a5c54",
    "tarball": "https://registry.npmjs.org/micro/-/micro-6.2.1.tgz"
  },
  "files": [
    "dist",
    "bin"
  ],
  "gitHead": "b86842dc4045d96fd31f03b9b9a02121252a69b4",
  "greenkeeper": {
    "emails": false
  },
  "homepage": "https://github.com/zeit/micro#readme",
  "keywords": [
    "micro",
    "service",
    "microservice",
    "serverless",
    "API"
  ],
  "license": "MIT",
  "main": "./dist/index.js",
  "maintainers": [
    {
      "name": "leo",
      "email": "mindrun@icloud.com"
    },
    {
      "name": "rauchg",
      "email": "rauchg@gmail.com"
    }
  ],
  "name": "micro",
  "optionalDependencies": {},
  "readme": "![](https://cldup.com/JDmmHX3uhF.svg)\n\n_**Micro —** Async ES6 HTTP microservices_\n\n[![Build Status](https://travis-ci.org/zeit/micro.svg?branch=master)](https://travis-ci.org/zeit/micro)\n[![Slack Channel](https://zeit-slackin.now.sh/badge.svg)](https://zeit.chat/)\n[![XO code style](https://img.shields.io/badge/code_style-XO-5ed9c7.svg)](https://github.com/sindresorhus/xo)\n\n## Features\n\n* **Easy**. Designed for usage with `async` and `await` ([more](https://zeit.co/blog/async-and-await))\n* **Fast**. Ultra-high performance (even JSON parsing is opt-in).\n* **Micro**. The whole project is ~100 lines of code.\n* **Agile**. Super easy deployment and containerization.\n* **Simple**. Oriented for single purpose modules (function).\n* **Explicit**. No middleware. Modules declare all dependencies.\n* **Standard**. Just HTTP!\n* **Lightweight**. The package is small and the `async` transpilation fast and transparent\n\n## Example\n\nThe following example `sleep.js` will wait before responding (without blocking!)\n\n```js\nconst {send} = require('micro')\nconst sleep = require('then-sleep')\n\nmodule.exports = async function (req, res) {\n  await sleep(500)\n  send(res, 200, 'Ready!')\n}\n```\n\nTo run the microservice on port `3000`, use the `micro` command:\n\n```bash\nmicro sleep.js\n```\n\nTo run the microservice on port `3000` and localhost instead of listening on every interface, use the `micro` command:\n\n```bash\nmicro -H localhost sleep.js\n```\n\n## Usage\n\nInstall the package (requires at least Node v6):\n\n```js\nnpm install --save micro\n```\n\nAnd start using it in your `package.json` file:\n\n```js\n\"main\": \"index.js\",\n\"scripts\": {\n  \"start\": \"micro\"\n}\n```\n\nThen write your `index.js` (see above for an example).\n\nAfter that, you can make the server run by executing the following command:\n\n```bash\nnpm start\n```\n\n### API\n\n#### micro\n**`micro(fn)`**\n\n- This function is exposed as the `default` export.\n- Use `require('micro')`.\n- Returns a [`http.Server`](https://nodejs.org/dist/latest-v4.x/docs/api/http.html#http_class_http_server) that uses the provided `fn` as the request handler.\n- The supplied function is run with `await`. It can be `async`!\n- Example:\n\n  ```js\n  const micro = require('micro');\n  const sleep = require('then-sleep');\n  const srv = micro(async function (req, res) {\n    await sleep(500);\n    res.writeHead(200);\n    res.end('woot');\n  });\n  srv.listen(3000);\n  ```\n\n#### json\n\n**`json(req, { limit = '1mb' })`**\n\n- Use `require('micro').json`.\n- Buffers and parses the incoming body and returns it.\n- Exposes an `async` function that can be run with  `await`.\n- Can be called multiple times, as it caches the raw request body the first time.\n- `limit` is how much data is aggregated before parsing at max. Otherwise, an `Error` is thrown with `statusCode` set to `413` (see [Error Handling](#error-handling)). It can be a `Number` of bytes or [a string](https://www.npmjs.com/package/bytes) like `'1mb'`.\n- If JSON parsing fails, an `Error` is thrown with `statusCode` set to `400` (see [Error Handling](#error-handling))\n- Example:\n\n  ```js\n  const { json, send } = require('micro');\n  module.exports = async function (req, res) {\n    const data = await json(req);\n    console.log(data.price);\n    send(res, 200);\n  }\n  ```\n\n#### send\n\n**`send(res, statusCode, data = null)`**\n\n- Use `require('micro').send`.\n- `statusCode` is a `Number` with the HTTP error code, and must always be supplied.\n- If `data` is supplied it is sent in the response. Different input types are processed appropriately, and `Content-Type` and `Content-Length` are automatically set.\n  - `Stream`: `data` is piped as an `octet-stream`. Note: it is _your_ responsibility to handle the `error` event in this case (usually, simply logging the error and aborting the response is enough).\n  - `Buffer`: `data` is written as an `octet-stream`.\n  - `object`: `data` is serialized as JSON.\n  - `string`: `data` is written as-is.\n- If JSON serialization fails (for example, if a cyclical reference is found), a `400` error is thrown. See [Error Handling](#error-handling).\n- Example\n\n  ```js\n  const { send } = require('micro')\n  module.exports = async function (req, res) {\n    send(res, 400, { error: 'Please use a valid email' });\n  }\n  ```\n\n#### return\n\n**`return val;`**\n\n- Returning `val` from your function is shorthand for: `send(res, 200, val)`.\n- Example\n\n  ```js\n  module.exports = function (req, res) {\n    return {message: 'Hello!'};\n  }\n  ```\n\n- Returning a promise works as well!\n- Example\n\n  ```js\n  const sleep = require('then-sleep')\n  module.exports = async function (req, res) {\n    return new Promise(async (resolve) => {\n      await sleep(100);\n      resolve('I Promised');\n    });\n  }\n  ```\n\n#### sendError\n\n**`sendError(req, res, error)`**\n\n- Use `require('micro').sendError`.\n- Used as the default handler for errors thrown.\n- Automatically sets the status code of the response based on `error.statusCode`.\n- Sends the `error.message` as the body.\n- During development (when `NODE_ENV` is set to `'development'`), stacks are printed out with `console.error` and also sent in responses.\n- Usually, you don't need to invoke this method yourself, as you can use the [built-in error handling](#error-handling) flow with `throw`.\n\n#### createError\n\n**`createError(code, msg, orig)`**\n\n- Use `require('micro').createError`.\n- Creates an error object with a `statusCode`.\n- Useful for easily throwing errors with HTTP status codes, which are interpreted by the [built-in error handling](#error-handling).\n- `orig` sets `error.originalError` which identifies the original error (if any).\n\n<a name=\"error-handling\"></a>\n\n### Error handling\n\nMicro allows you to write robust microservices. This is accomplished primarily by bringing sanity back to error handling and avoiding callback soup.\n\nIf an error is thrown and not caught by you, the response will automatically be `500`. **Important:** during development mode (if the env variable `NODE_ENV` is `'development'`), error stacks will be printed as `console.error` and included in the responses.\n\nIf the `Error` object that's thrown contains a `statusCode` property, that's used as the HTTP code to be sent. Let's say you want to write a rate limiting module:\n\n```js\nconst rateLimit = require('my-rate-limit')\nmodule.exports = async function (req, res) {\n  await rateLimit(req);\n  // … your code\n}\n```\n\nIf the API endpoint is abused, it can throw an error like so:\n\n```js\nif (tooMany) {\n  const err = new Error('Rate limit exceeded');\n  err.statusCode = 429;\n  throw err;\n}\n```\n\nAlternatively you can use ``createError`` as described above.\n\n```js\nif (tooMany) {\n  throw createError(429, 'Rate limit exceeded')\n}\n```\n\nThe nice thing about this model is that the `statusCode` is merely a suggestion. The user can override it:\n\n```js\ntry {\n  await rateLimit(req);\n} catch (err) {\n  if (429 == err.statusCode) {\n    // perhaps send 500 instead?\n    send(res, 500);\n  }\n}\n```\n\nIf the error is based on another error that **Micro** caught, like a `JSON.parse` exception, then `originalError` will point to it.\n\nIf a generic error is caught, the status will be set to `500`.\n\nIn order to set up your own error handling mechanism, you can use composition in your handler:\n\n```js\nmodule.exports = handleErrors(async (req, res) => {\n  throw new Error('What happened here?');\n});\n\nfunction handleErrors (fn) {\n  return async function (req, res) {\n    try {\n      return await fn(req, res);\n    } catch (err) {\n      console.log(err.stack);\n      send(res, 500, 'My custom error!');\n    }\n  }\n}\n```\n\n### Testing\n\nMicro makes tests compact and a pleasure to read and write.\nWe recommend [ava](https://github.com/sindresorhus/ava), a highly parallel micro test framework with built-in support for async tests:\n\n```js\nconst micro = require('micro');\nconst test = require('ava');\nconst listen = require('test-listen');\nconst request = require('request-promise');\n\ntest('my endpoint', async t => {\n  const service = micro(async function (req, res) {\n    micro.send(res, 200, { test: 'woot' })\n  });\n\n  const url = await listen(service);\n  const body = await request(url);\n  t.deepEqual(JSON.parse(body).test, 'woot');\n});\n```\n\nLook at the [test-listen](https://github.com/zeit/test-listen) for a\nfunction that returns a URL with an ephemeral port every time it's called.\n\n### Transpilation\n\nWe use [is-async-supported](https://github.com/timneutkens/is-async-supported) combined with [async-to-gen](https://github.com/leebyron/async-to-gen),\nso that the we only convert `async` and `await` to generators when needed.\n\nIf you want to do it manually, you can! `micro(1)` is idempotent and\nshould not interfere.\n\n`micro` exclusively supports Node 6+ to avoid a big transpilation\npipeline. `async-to-gen` is fast and can be distributed with\nthe main `micro` package due to its small size.\n\n### Deployment\n\nYou can use the `micro` CLI for `npm start`:\n\n```json\n{\n  \"name\": \"my-microservice\",\n  \"dependencies\": {\n    \"micro\": \"x.y.z\"\n  },\n  \"main\": \"microservice.js\",\n  \"scripts\": {\n    \"start\": \"micro -p 3000\"\n  }\n}\n```\n\nThen simply run `npm start`!\n\n## Contribute\n\n1. [Fork](https://help.github.com/articles/fork-a-repo/) this repository to your own GitHub account and then [clone](https://help.github.com/articles/cloning-a-repository/) it to your local device\n2. Link the package to the global module directory: `npm link`\n3. Transpile the source code and watch for changes: `npm start`\n4. Within the module you want to test your local development instance of micro, just link it to the dependencies: `npm link micro`. Instead of the default one from npm, node will now use your clone of micro!\n\nAs always, you can run the [AVA](https://github.com/sindresorhus/ava) and [ESLint](http://eslint.org) tests using: `npm test`\n\n## Credits\n\nThanks Tom Yandell and Richard Hodgson for donating the  `micro` npm name.\n\n## Authors\n\n- Guillermo Rauch ([@rauchg](https://twitter.com/rauchg)) - [▲ZEIT](https://zeit.co)\n- Leo Lamprecht ([@notquiteleo](https://twitter.com/notquiteleo)) - [▲ZEIT](https://zeit.co)\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/zeit/micro.git"
  },
  "scripts": {
    "build": "mkdir -p dist && async-to-gen lib/index.js > dist/index.js",
    "prepublish": "npm run build",
    "pretest": "npm run build",
    "test": "xo && ava"
  },
  "version": "6.2.1",
  "xo": {
    "esnext": true,
    "space": true,
    "semicolon": false,
    "rules": {
      "max-lines": 0,
      "ava/no-ignored-test-files": 0,
      "no-labels": 0,
      "no-unused-labels": 0,
      "no-unused-expressions": 0,
      "yoda": 0,
      "no-negated-condition": 0
    }
  }
}
